A graph is a set of vertices and a collection of edges that each connect a pair of vertices.

A self-loop is an edge that connects a vertex to itself.

Two edges that connect the same pair of vertices are parallel

When there is an edge connecting two vertices, we say that the vertices are a djacent
to one another and that the edge is incident to both vertices

The degree of a vertex is the number of edges incident to it.

A subgraph is a subset of a graph’s edges (and associated vertices) that constitutes a graph.

A path in a graph is a sequence of vertices connected by edges. 

A simple path is one with no repeated vertices. 

A cycle is a path with at least one edge whose first and last vertices are the same. 

A simple cycle is a cycle with no repeated edges or vertices (except the requisite repetition of the first and last vertices). 

The length of a path or a cycle is its number of edges.

A graph is connected if there is a path from every vertex to every other vertex in the graph. 

A graph that is not connected consists of a set of connected components, which are maximal connected subgraphs

An acyclic graph is a graph with no cycles. 
Several of the algorithms that we consider are concerned with finding acyclic subgraphs of a given graph that satisfy certain properties.

A tree is an acyclic connected graph. 
A disjoint set of trees is called a forest. 
A spanning tree of a connected graph is a subgraph that contains all of that graph’s vertices and is a single tree. 
A spanning forest of a graph is the union of spanning trees of its connected components.

The density of a graph is the proportion of possible pairs of vertices that are connected by edges. 
A sparse graph has relatively few of the possible edges present;
a dense graph has relatively few of the possible edges missing. 
Generally, we think of a graph as being sparse if its number of different edges is within a small constant factor of V and as being
dense otherwise.

A bipartite graph is a graph whose vertices we can divide into two sets
such that all edges connect a vertex in one set with a vertex in the other
set.


Graph Representation

An adjacency matrix, 
where we maintain a V-by-V boolean array, with the entry in row v and column w defined to be true if there is an edge adjacent
to both vertex v and vertex w in the graph, and to be false otherwise. This representation fails on the first count— 
graphs with millions of vertices are common and the space cost for the V 2 boolean values needed is prohibitive.

An array of edges, 
using an Edge class with two instance variables of type int. This direct representation is simple, but it fails on the second count—
implementing adj() would involve examining all the edges in the graph.

An array of adjacency lists, 
where wemaintain a vertex-indexed array of lists of the vertices adjacent to each vertex.
Graph implementation achieves the following performance characteristics:
- Space usage proportional to V + E
- Constant time to add an edge
- Time proportional to the degree of v to iterate through vertices adjacent to v
(constant time per adjacent vertex processed)

DFS marks all the vertices connected to a given source in time proportional to the sum of their degrees
DFS uses preprocessing time and space proportional to V+E to
support constant-time connectivity queries in a graph

DFS based
Connectivity. Given a graph, support queries of the form Are two given vertices
connected ? and How many connected components does the graph have ?
Are two given vertices connected?
Single-source paths. Given a graph and a source vertex s, support queries of the
form Is there a path from s to a given target vertex v? If so, find such a path

BFS
For any vertex v reachable from s, BFS computes a shortest path
from s to v (no path from s to v has fewer edges).

Single-source shortest paths. Given a graph and a source vertex s, support queries
of the form Is there a path from s to a given target vertex v? If so, find a shortest
such path (one with a minimal number of edges).

BFS takes time proportional to V + E in the worst case.


1. find all connected vertices from a starting point - DFS
DFS marks all vertices connected to a given source in time propotional to the sum of their degrees	

2. find path from source s to vertex v - DFS
DFS with a union find kind of array startinf from source s, mark the adjuscent vertex root as s and keep doing for all.
at same time mark boolean visited array as true for vertex traversed.
if a node is visited it means it is connected, now use root array to find path from vertex v to source s using union find
DFS allow us to provide conned path to from a given source in time propotional to its length

3. shortest path from vertex v to source s - BFS
use Queue for BFS, use boolean visited array and root array to union find the shortest path 
For any vertex v reachable from source s, BFS computes the shortest path from s to v

BFS takes time proportional to V + E in the worst case.

4. Connected componentes/ sub graphs - DFS
use DFS, boolean visited array, id array and count++
DFS for every vertex in graph

4. is graph acyclic - DFS

5. is graph bipartite - DFS
using boolean color array




Symbol table
has a hashmap for string to its int index map
has a String ayyar where by int index you can get String name
has a graph which uses name to find index and index to find name using above hashmap and String array


Degrees of Separation
one of the classic application of graph application is to find degree of separation between two individuals in a social network


A knows B, B knows C - so considering A as 0th level, B has got level 1 and C has got level 2
C knows D, but D directly knows A - so D has got level 1

Degree of Separation is about shortest path from source to destination so - BFS



Directed Graphs

in directed graphs: edges are one way, the pair of vertices thast defined as edge is an ordered pair that specifies a one way adjacency

A Directed graph or a digraph is a set of vertices and a collection of directed edges.
Each directed edge connects an ordered pair of vertices

































